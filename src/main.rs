//! Example usage of the Cluv video processing library

use cluv::{
    AudioFilter, CluvOptions, Filters, KeyValue, Snapshot, SnapshotParams, SpriteParams,
    SubTranscodeParams, TranscodeParams, TranscodeVideoFilter, Transcoder,
};
use std::env;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        print_usage();
        return Ok(());
    }

    let command = &args[1];

    match command.as_str() {
        "transcode" => {
            if args.len() < 4 {
                println!("Usage: {} transcode <input_file> <output_file>", args[0]);
                return Ok(());
            }
            transcode_example(&args[2], &args[3]).await?;
        }
        "snapshot" => {
            if args.len() < 4 {
                println!("Usage: {} snapshot <input_file> <output_file>", args[0]);
                return Ok(());
            }
            snapshot_example(&args[2], &args[3]).await?;
        }
        "sprite" => {
            if args.len() < 4 {
                println!("Usage: {} sprite <input_file> <output_file>", args[0]);
                return Ok(());
            }
            sprite_example(&args[2], &args[3]).await?;
        }
        "hls" => {
            if args.len() < 4 {
                println!("Usage: {} hls <input_file> <output_file>", args[0]);
                return Ok(());
            }
            hls_example(&args[2], &args[3]).await?;
        }
        "multi" => {
            if args.len() < 3 {
                println!("Usage: {} multi <input_file>", args[0]);
                return Ok(());
            }
            multi_output_example(&args[2]).await?;
        }
        _ => {
            println!("Unknown command: {}", command);
            print_usage();
        }
    }

    Ok(())
}

fn print_usage() {
    println!("Cluv - A friendly FFmpeg wrapper for Rust");
    println!();
    println!("Usage: cluv <command> [options]");
    println!();
    println!("Commands:");
    println!("  transcode <input> <output>  - Transcode video to MP4");
    println!("  snapshot <input> <output> - Take a snapshot");
    println!("  sprite <input> <output>     - Generate sprite sheet");
    println!("  hls <input> <output>        - Convert to HLS format");
    println!("  multi <input>               - Multiple output example");
    println!();
    println!("Examples:");
    println!("  cluv transcode input.mov output.mp4");
    println!("  cluv snapshot input.mp4 thumbnail.jpg");
    println!("  cluv sprite input.mp4 sprite.jpg");
    println!("  cluv hls input.mp4 output.m3u8");
    println!("  cluv multi input.mp4");
}

/// Example: Simple video transcoding to MP4
async fn transcode_example(input: &str, output: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("Transcoding {} to {}", input, output);

    let transcoder = Transcoder::new();

    let params = TranscodeParams::builder()
        .input_file(input)
        .add_sub(SubTranscodeParams {
            output_file: output.to_string(),
            filters: Some(Filters {
                container: None,
                metadata: vec![
                    KeyValue {
                        key: "title".to_string(),
                        value: "Transcoded with Cluv".to_string(),
                    },
                    KeyValue {
                        key: "comment".to_string(),
                        value: "Generated by Rust Cluv library".to_string(),
                    },
                ],
                video: Some(TranscodeVideoFilter {
                    codec: Some("libx264".to_string()),
                    width: Some(1920),
                    height: Some(1080),
                    short: None,
                    fps: None,
                    crf: Some(23),
                    quality: None,
                    bitrate: None,
                    gop: None,
                    pts: None,
                    apts: None,
                    pix_fmt: None,
                }),
                audio: Some(AudioFilter {
                    codec: Some("aac".to_string()),
                    bitrate: Some(128),
                }),
                logo: Vec::new(),
                delogo: Vec::new(),
                clip: None,
                hls: None,
            }),
            threads: Some(4),
        })
        .build()?;

    transcoder.simple_mp4(params).await?;
    println!("Transcoding completed successfully!");

    Ok(())
}

/// Example: Taking a snapshot
async fn snapshot_example(input: &str, output: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("Taking snapshot from {} to {}", input, output);

    let snapshot = Snapshot::new();

    let params = SnapshotParams::builder()
        .input_file(input)
        .output_file(output)
        .single_snapshot()
        .start_time(30.0) // Take snapshot at 30 seconds
        .resolution(1280, 720)
        .build()?;

    snapshot.simple(params).await?;
    println!("snapshot taken successfully!");

    Ok(())
}

/// Example: Generating a sprite sheet
async fn sprite_example(input: &str, output: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("Generating sprite sheet from {} to {}", input, output);

    let snapshot = Snapshot::new();

    let params = SpriteParams::builder()
        .input_file(input)
        .output_file(output)
        .grid(5, 4) // 5 columns, 4 rows = 20 thumbnails
        .thumbnail_size(160, 90) // 160x90 pixel thumbnails
        .interval(2.0) // 2 seconds between frames
        .build()?;

    snapshot.sprite(params).await?;
    println!("Sprite sheet generated successfully!");

    Ok(())
}

/// Example: Converting to HLS
async fn hls_example(input: &str, output: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("Converting {} to HLS format: {}", input, output);

    let transcoder = Transcoder::new();

    let params = cluv::TranscodeHlsParams {
        input_file: input.to_string(),
        output_file: output.to_string(),
        filters: Some(Filters {
            container: None,
            metadata: Vec::new(),
            video: Some(TranscodeVideoFilter {
                codec: Some("libx264".to_string()),
                width: Some(1280),
                height: Some(720),
                short: None,
                fps: None,
                crf: Some(23),
                quality: None,
                bitrate: None,
                gop: Some(60), // 2 second GOP at 30fps
                pts: None,
                apts: None,
                pix_fmt: None,
            }),
            audio: Some(AudioFilter {
                codec: Some("aac".to_string()),
                bitrate: Some(128),
            }),
            logo: Vec::new(),
            delogo: Vec::new(),
            clip: None,
            hls: Some(cluv::HlsOptions {
                segment_type: Some("mpegts".to_string()),
                flags: Some("independent_segments".to_string()),
                playlist_type: Some("vod".to_string()),
                time: Some(6), // 6 second segments
                master_playlist_name: None,
                segment_filename: Some("segment_%03d.ts".to_string()),
            }),
        }),
        threads: Some(4),
    };

    transcoder.simple_hls(params).await?;
    println!("HLS conversion completed successfully!");

    Ok(())
}

/// Example: Multiple outputs with different settings
async fn multi_output_example(input: &str) -> Result<(), Box<dyn std::error::Error>> {
    println!("Creating multiple outputs from {}", input);

    let transcoder = Transcoder::new();

    let params = TranscodeParams::builder()
        .input_file(input)
        .add_sub(SubTranscodeParams {
            output_file: "output_720p.mp4".to_string(),
            filters: Some(Filters {
                container: None,
                metadata: vec![KeyValue {
                    key: "title".to_string(),
                    value: "720p Version".to_string(),
                }],
                video: Some(TranscodeVideoFilter {
                    codec: Some("libx264".to_string()),
                    width: Some(1280),
                    height: Some(720),
                    short: None,
                    fps: None,
                    crf: Some(23),
                    quality: None,
                    bitrate: None,
                    gop: None,
                    pts: None,
                    apts: None,
                    pix_fmt: None,
                }),
                audio: Some(AudioFilter {
                    codec: Some("aac".to_string()),
                    bitrate: Some(128),
                }),
                logo: Vec::new(),
                delogo: Vec::new(),
                clip: None,
                hls: None,
            }),
            threads: Some(2),
        })
        .add_sub(SubTranscodeParams {
            output_file: "output_480p.mp4".to_string(),
            filters: Some(Filters {
                container: None,
                metadata: vec![KeyValue {
                    key: "title".to_string(),
                    value: "480p Version".to_string(),
                }],
                video: Some(TranscodeVideoFilter {
                    codec: Some("libx264".to_string()),
                    width: Some(854),
                    height: Some(480),
                    short: None,
                    fps: None,
                    crf: Some(25),
                    quality: None,
                    bitrate: None,
                    gop: None,
                    pts: None,
                    apts: None,
                    pix_fmt: None,
                }),
                audio: Some(AudioFilter {
                    codec: Some("aac".to_string()),
                    bitrate: Some(96),
                }),
                logo: Vec::new(),
                delogo: Vec::new(),
                clip: None,
                hls: None,
            }),
            threads: Some(2),
        })
        .add_sub(SubTranscodeParams {
            output_file: "output_audio.mp3".to_string(),
            filters: Some(Filters {
                container: None,
                metadata: vec![KeyValue {
                    key: "title".to_string(),
                    value: "Audio Only".to_string(),
                }],
                video: None,
                audio: Some(AudioFilter {
                    codec: Some("libmp3lame".to_string()),
                    bitrate: Some(192),
                }),
                logo: Vec::new(),
                delogo: Vec::new(),
                clip: None,
                hls: None,
            }),
            threads: Some(1),
        })
        .build()?;

    // For MP3 output, use simple_mp3 method
    let mp3_params = TranscodeParams {
        input_file: input.to_string(),
        subs: vec![params.subs[2].clone()],
    };

    // For MP4 outputs, use simple_mp4 method
    let mp4_params = TranscodeParams {
        input_file: input.to_string(),
        subs: vec![params.subs[0].clone(), params.subs[1].clone()],
    };

    println!("Creating MP4 outputs...");
    transcoder.simple_mp4(mp4_params).await?;

    println!("Creating MP3 output...");
    transcoder.simple_mp3(mp3_params).await?;

    println!("All outputs created successfully!");
    println!("Generated files:");
    println!("  - output_720p.mp4 (1280x720)");
    println!("  - output_480p.mp4 (854x480)");
    println!("  - output_audio.mp3 (audio only)");

    Ok(())
}

/// Example of using custom FFmpeg options
#[allow(dead_code)]
async fn advanced_example() -> Result<(), Box<dyn std::error::Error>> {
    use cluv::LogLevel;

    // Create custom options
    let options = CluvOptions::new().with_ffmpeg(|opts| {
        opts.log_level(LogLevel::Debug)
            .debug(true)
            .binary_path("/usr/local/bin/ffmpeg")
            .add_arg("-preset")
            .add_arg("slow")
    });

    // Use with transcoder
    let transcoder = Transcoder::with_options(options);

    let params = TranscodeParams::builder()
        .input_file("input.mp4")
        .add_output("output.mp4")
        .build()?;

    transcoder.simple_mp4(params).await?;

    Ok(())
}
